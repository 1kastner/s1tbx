/*
 * Copyright (C) 2014 by Array Systems Computing Inc. http://www.array.ca
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option)
 * any later version.
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see http://www.gnu.org/licenses/
 */
package org.esa.s1tbx.calibration.gpf;

import com.bc.ceres.core.ProgressMonitor;
import org.esa.s1tbx.calibration.gpf.calibrators.Sentinel1Calibrator;
import org.esa.s1tbx.insar.gpf.support.Sentinel1Utils;
import org.esa.snap.core.datamodel.*;
import org.esa.snap.core.dataop.downloadable.StatusProgressMonitor;
import org.esa.snap.core.gpf.Operator;
import org.esa.snap.core.gpf.OperatorException;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.Tile;
import org.esa.snap.core.gpf.annotations.OperatorMetadata;
import org.esa.snap.core.gpf.annotations.Parameter;
import org.esa.snap.core.gpf.annotations.SourceProduct;
import org.esa.snap.core.gpf.annotations.TargetProduct;
import org.esa.snap.core.util.ProductUtils;
import org.esa.snap.core.util.SystemUtils;
import org.esa.snap.core.util.math.MathUtils;
import org.esa.snap.engine_utilities.datamodel.AbstractMetadata;
import org.esa.snap.engine_utilities.datamodel.Unit;
import org.esa.snap.engine_utilities.eo.Constants;
import org.esa.snap.engine_utilities.gpf.InputProductValidator;
import org.esa.snap.engine_utilities.gpf.OperatorUtils;
import org.esa.snap.engine_utilities.gpf.ThreadManager;
import org.esa.snap.engine_utilities.gpf.TileIndex;
import org.esa.snap.engine_utilities.util.Maths;

import java.awt.*;
import java.io.IOException;
import java.util.*;
import java.util.List;

/**
 * Mask "No-value" pixels for near-range region in a Sentinel-1 Level-1 GRD product.
 * <p>
 * [1] "Masking No-value Pixels on GRD Products generated by the Sentinel-1 ESA IPF",
 * OI-MPC-OTH-0243-S1-Border-Masking-MPCS-916.
 */
@OperatorMetadata(alias = "Remove-GRD-Border-Noise",
        category = "Radar/Sentinel-1 TOPS",
        authors = "Jun Lu, Luis Veci",
        copyright = "Copyright (C) 2014 by Array Systems Computing Inc.",
        version = "1.0",
        description = "Mask no-value pixels for GRD product")
public final class RemoveGRDBorderNoiseOp extends Operator {

    @SourceProduct
    private Product sourceProduct;

    @TargetProduct
    private Product targetProduct;

    @Parameter(description = "The list of polarisations", label = "Polarisations")
    private String[] selectedPolarisations;

    @Parameter(description = "The border margin limit", defaultValue = "500", label = "Border margin limit[pixels]")
    private int borderLimit = 500;

    @Parameter(description = "The trim threshold", defaultValue = "0.5", label = "Threshold")
    private double trimThreshold = 0.5;

    private MetadataElement absRoot = null;
    private MetadataElement origMetadataRoot = null;
    private int sourceImageWidth = 0;
    private int sourceImageHeight = 0;
    private double version = 0.0f;
    private double scalingFactor = 0.0;
    private Double noDataValue = 0.0;
    private String coPolarization = null;
    private Sentinel1Utils.NoiseVector noiseVector = null;
    private double[] noiseLUT = null;
    private Band coPolBand = null;
    private boolean thermalNoiseCorrectionPerformed = false;

    private boolean useBorderDetection = true;
    private boolean borderDetected = false;
    private int topBorder = 0;
    private int bottomBorder = 0;
    private int leftBorder = 0;
    private int rightBorder = 0;

    // For after IPF 2.9.0 ...

    // The key is something like "s1a-iw-grd-hh-..."
    private HashMap<String, Double> t0Map = new HashMap<>();
    private HashMap<String, Double> deltaTsMap = new HashMap<>();

    // The key to these maps is pol, e.g. "hh"
    //private HashMap<String, Sentinel1Utils.NoiseAzimuthVector[] > noiseAzimuthVectorMap = new HashMap<>();
    //private HashMap<String, NoiseAzimuthBlock[] > noiseAzimuthBlockMap = new HashMap<>(); //  NoiseAzimuthBlock[i] can be null but should never be
    //private HashMap<String, Sentinel1Utils.NoiseVector[]> noiseRangeVectorMap = new HashMap<>();

    // key is pol+swath, e.g. "hh+IW1" or "hh+EW1"
    private HashMap<String, double[]> swathStartEndTimesMap = new HashMap<>();

    /**
     * Default constructor. The graph processing framework
     * requires that an operator has a default constructor.
     */
    public RemoveGRDBorderNoiseOp() {
    }

    /**
     * Initializes this operator and sets the one and only target product.
     * <p>The target product can be either defined by a field of type {@link Product}
     * annotated with the {@link TargetProduct TargetProduct} annotation or
     * by calling {@link #setTargetProduct} method.</p>
     * <p>The framework calls this method after it has created this operator.
     * Any client code that must be performed before computation of tile data
     * should be placed here.</p>
     *
     * @throws OperatorException If an error occurs during operator initialisation.
     * @see #getTargetProduct()
     */
    @Override
    public void initialize() throws OperatorException {

        try {
            final InputProductValidator validator = new InputProductValidator(sourceProduct);
            validator.checkIfSentinel1Product();
            validator.checkIfGRD();
            validator.checkIfCalibrated(false);

            absRoot = AbstractMetadata.getAbstractedMetadata(sourceProduct);
            origMetadataRoot = AbstractMetadata.getOriginalProductMetadata(sourceProduct);

            sourceImageWidth = sourceProduct.getSceneRasterWidth();
            sourceImageHeight = sourceProduct.getSceneRasterHeight();

            topBorder = borderLimit;
            bottomBorder = sourceImageHeight - borderLimit;
            leftBorder = borderLimit;
            rightBorder = sourceImageWidth - borderLimit;

            getIPFVersion();

            getProductCoPolarization();

            getThermalNoiseCorrectionFlag();
            //System.out.println("thermalNoiseCorrectionPerformed = " + thermalNoiseCorrectionPerformed);

            if (version < 2.9) {
                if (!thermalNoiseCorrectionPerformed) {
                    getThermalNoiseVector();
                }
            } else {
                getThermalNoiseVectors();
            }

            computeNoiseScalingFactor();

            if (version < 2.9) {
                computeNoiseLUT();
            }

            createTargetProduct();

        } catch (Throwable e) {
            OperatorUtils.catchOperatorException(getId(), e);
        }
    }

    /**
     * Get IPF version.
     */
    private void getIPFVersion() {

        final String procSysId = absRoot.getAttributeString(AbstractMetadata.ProcessingSystemIdentifier);
        version = Double.valueOf(procSysId.substring(procSysId.lastIndexOf(" ")));
        //System.out.println("RemoveGRDBorderNoise: IPF version = " + version);
    }

    /**
     * Get product co-polarization.
     */
    private void getProductCoPolarization() {

        final String[] sourceBandNames = sourceProduct.getBandNames();
        for (String bandName : sourceBandNames) {
            if (bandName.contains("HH")) {
                coPolarization = "HH";
                coPolBand = sourceProduct.getBand(bandName);
                break;
            } else if (bandName.contains("VV")) {
                coPolarization = "VV";
                coPolBand = sourceProduct.getBand(bandName);
                break;
            }
        }

        if (coPolarization == null) {
            throw new OperatorException("Input product does not contain band with HH or VV polarization");
        }
        noDataValue = coPolBand.getNoDataValue();
    }

    /**
     * Get thermal noise correction flag from the original product metadata.
     */
    private void getThermalNoiseCorrectionFlag() {

        final MetadataElement annotationElem = origMetadataRoot.getElement("annotation");
        final MetadataElement[] annotationDataSetListElem = annotationElem.getElements();
        final MetadataElement productElem = annotationDataSetListElem[0].getElement("product");
        final MetadataElement imageAnnotationElem = productElem.getElement("imageAnnotation");
        final MetadataElement processingInformationElem = imageAnnotationElem.getElement("processingInformation");

        thermalNoiseCorrectionPerformed = Boolean.parseBoolean(
                processingInformationElem.getAttribute("thermalNoiseCorrectionPerformed").getData().getElemString());
    }

    /**
     * Get the middle thermal noise vector from the original product metadata.
     */
    private void getThermalNoiseVector() {

        final MetadataElement noiseElem = origMetadataRoot.getElement("noise");
        final MetadataElement[] noiseDataSetListElem = noiseElem.getElements();

        for (MetadataElement dataSetListElem : noiseDataSetListElem) {
            final MetadataElement noiElem = dataSetListElem.getElement("noise");
            final MetadataElement adsHeaderElem = noiElem.getElement("adsHeader");
            final String pol = adsHeaderElem.getAttributeString("polarisation");
            if (coPolarization.contains(pol)) {
                final MetadataElement noiseVectorListElem = noiElem.getElement("noiseVectorList");
                final int count = Integer.parseInt(noiseVectorListElem.getAttributeString("count"));
                Sentinel1Utils.NoiseVector[] noiseVectorList = Sentinel1Utils.getNoiseVector(noiseVectorListElem);
                noiseVector = noiseVectorList[count / 2];
                break;
            }
        }

        if (noiseVector == null) {
            throw new OperatorException("Input product does not have noise vector for HH or VV band");
        }
    }

    private void getT0andDeltaTS(final String imageName) {

        // imageName is something like s1a-iw-grd-hh-...

        final MetadataElement annotationElem = origMetadataRoot.getElement("annotation");
        final MetadataElement[] annotationDataSetListElem = annotationElem.getElements();

        for (MetadataElement dataSetListElem : annotationDataSetListElem) {
             if (dataSetListElem.getName().equals(imageName)){
                 //System.out.println("getT0andDeltaTS: found " + imageName);

                 MetadataElement productElem = dataSetListElem.getElement("product");
                 MetadataElement imageAnnotationElem = productElem.getElement("imageAnnotation");
                 MetadataElement imageInformationElem = imageAnnotationElem.getElement("imageInformation");

                 double t01 = absRoot.getAttributeUTC(AbstractMetadata.first_line_time).getMJD(); // just for comparison
                 double t0 = Sentinel1Utils.getTime(imageInformationElem ,"productFirstLineUtcTime").getMJD();
                 t0Map.put(imageName, t0);

                 double deltaTS1 = absRoot.getAttributeDouble(AbstractMetadata.line_time_interval) / Constants.secondsInDay; // just for comparison
                 double deltaTS = imageInformationElem.getAttributeDouble("azimuthTimeInterval") / Constants.secondsInDay; // s to day
                 deltaTsMap.put(imageName, deltaTS);

                 //System.out.println("getT0andDeltaTS: " + imageName + ": t01 = " + t01 + " t0 = " + t0 + " deltaTS1 = " + deltaTS1 + " deltaTS = " + deltaTS);

                 break;
             }
        }
    }

    private void getThermalNoiseVectors() {

        final MetadataElement noiseElem = origMetadataRoot.getElement("noise");
        final MetadataElement[] noiseDataSetListElem = noiseElem.getElements();

        // loop through s1a-iw-grd-hh-..., s1a-iw-grd-hv-...
        for (MetadataElement dataSetListElem : noiseDataSetListElem) {

            // imageName is s1a-iw-grd-hh-...
            final String imageName = dataSetListElem.getName();
            getT0andDeltaTS(imageName);
            final double firstLineTime = t0Map.get(imageName);
            final double lineTimeInterval = deltaTsMap.get(imageName);

            final MetadataElement noiElem = dataSetListElem.getElement("noise");
            final MetadataElement adsHeaderElem = noiElem.getElement("adsHeader");
            final String pol = adsHeaderElem.getAttributeString("polarisation");

            // get the noise azimuth vectors
            MetadataElement noiseAzimuthVectorListElem = noiElem.getElement("noiseAzimuthVectorList");
            final Sentinel1Utils.NoiseAzimuthVector[] noiseAzimuthVectors =
                    Sentinel1Utils.getAzimuthNoiseVector(noiseAzimuthVectorListElem);
            //noiseAzimuthVectorMap.put(pol, noiseAzimuthVectors);

            //System.out.println("getThermalNoiseVectors: # azim noise vectors = " + noiseAzimuthVectors.length);

            // get the noise range vectors
            MetadataElement noiseRangeVectorListElem = noiElem.getElement("noiseRangeVectorList");
            final Sentinel1Utils.NoiseVector[] noiseRangeVectors =
                    Sentinel1Utils.getNoiseVector(noiseRangeVectorListElem);
            /*
            for (int i = 0; i < noiseRangeVectors.length; i++) {
                System.out.println(pol + ": noiseRangeVectors[" + i + "].line = " + noiseRangeVectors[i].line
                    + "; azim time = " + noiseRangeVectors[i].timeMJD);
            }
            */
            //noiseRangeVectorMap.put(pol, noiseRangeVectors);

            NoiseAzimuthBlock[] noiseAzimuthBlocks = new NoiseAzimuthBlock[noiseAzimuthVectors.length];
            for (int i = 0; i < noiseAzimuthBlocks.length; i++) {

                //noiseAzimuthBlocks[i] = getNoiseAzimuthBlock(noiseAzimuthVectors[i]); // can be null but should never be
                double interpolatedAzimuthVector[] = interpolNoiseAzimuthVector(noiseAzimuthVectors[i]);

                final double startAzimTime = firstLineTime + noiseAzimuthVectors[i].firstAzimuthLine * lineTimeInterval;
                final double endAzimTime = firstLineTime + noiseAzimuthVectors[i].lastAzimuthLine * lineTimeInterval;
                final String swath = noiseAzimuthVectors[i].swath;
                int[] noiseRangeVecIndices = getNoiseRangeVectorIndices(
                        pol, swath, startAzimTime, endAzimTime, noiseRangeVectors,
                        noiseAzimuthVectors[i].firstAzimuthLine, noiseAzimuthVectors[i].lastAzimuthLine);
                /*
                System.out.println("pol = " + pol + " swath = " + swath + " firstAzimuthLine = " + noiseAzimuthVectors[i].firstAzimuthLine
                        + " lastAzimuthLine = " + noiseAzimuthVectors[i].lastAzimuthLine
                        + " startAzimTime = " + startAzimTime + " endAzimTime = " + endAzimTime
                        + " noiseRangeVecIdx.length = "
                        + ((noiseRangeVecIndices == null) ? "null" : noiseRangeVecIndices.length));
                */
                final int numLines = noiseAzimuthVectors[i].lastAzimuthLine
                        - noiseAzimuthVectors[i].firstAzimuthLine + 1;
                final int numSamples = noiseAzimuthVectors[i].lastRangeSample
                        - noiseAzimuthVectors[i].firstRangeSample + 1;

                double interpNoiseRangeMatrix[][] = new double[numLines][numSamples];

                if (noiseRangeVecIndices != null && noiseRangeVecIndices.length > 0) {

                    double interpolatedRangeVectors[][] = new double[noiseRangeVecIndices.length][numSamples];
                    int noiseRangeVectorLine[] = new int[noiseRangeVecIndices.length];
                    for (int j = 0; j < noiseRangeVecIndices.length; j++) {
                        //System.out.println("   noiseRangeVecIdx[" + j + "] = " + noiseRangeVecIndices[j]);
                        noiseRangeVectorLine[j] = noiseRangeVectors[noiseRangeVecIndices[j]].line;
                        interpolNoiseRangeVector(noiseRangeVectors[noiseRangeVecIndices[j]],
                                noiseAzimuthVectors[i].firstRangeSample, noiseAzimuthVectors[i].lastRangeSample,
                                interpolatedRangeVectors[j]);
                    }

                    computeNoiseRangeMatrix(noiseAzimuthVectors[i].firstAzimuthLine,
                            noiseAzimuthVectors[i].lastAzimuthLine, noiseRangeVectorLine,
                            interpolatedRangeVectors, interpNoiseRangeMatrix);
                } else {
                    for (int row = 0; row < numLines; row++) {
                        for (int col = 0; col < numSamples; col++) {
                            interpNoiseRangeMatrix[row][col] = 1.0;
                        }
                    }
                }

                final double noiseMatrix[][] = new double[numLines][numSamples];


                for (int row = 0; row < numLines; row++) {
                    for (int col = 0; col < numSamples; col++) {
                        noiseMatrix[row][col] = interpolatedAzimuthVector[row] * interpNoiseRangeMatrix[row][col];
                    }
                }

                noiseAzimuthBlocks[i] = new NoiseAzimuthBlock(swath, noiseAzimuthVectors[i].firstAzimuthLine,
                        noiseAzimuthVectors[i].firstRangeSample, noiseAzimuthVectors[i].lastAzimuthLine,
                        noiseAzimuthVectors[i].lastRangeSample, noiseMatrix);
            }

            //noiseAzimuthBlockMap.put(pol, noiseAzimuthBlocks);
        }

        //System.out.println("getThermalNoiseVectors DONE");
    }

    private void interpolNoiseRangeVector(final Sentinel1Utils.NoiseVector noiseRangeVector,
                                          final int firstRangeSample, final int lastRangeSample,
                                          final double[] result) {
        /*
        System.out.println("interpolNoiseRangeVector called firstRangeSample = " + firstRangeSample
            + " lastRangeSample = " + lastRangeSample + " pixels = " + noiseRangeVector.pixels[0]
            + ", " + noiseRangeVector.pixels[noiseRangeVector.pixels.length-1]);
        */

        if (noiseRangeVector.pixels.length < 2) {  // should never happen
            SystemUtils.LOG.warning("######### noise range vector has length 1");
            for (int sample = 0; sample < result.length; sample++) {
                result[sample] = noiseRangeVector.pixels[0];
            }
        }  else {

            int i = 0;
            int sampleIdx = getSampleIndex(firstRangeSample, noiseRangeVector);
            /*
            System.out.println("interpolNoiseRangeVector: sampleIdx = " + sampleIdx
                + ": " + noiseRangeVector.pixels[sampleIdx] + " " + noiseRangeVector.pixels[sampleIdx+1]);
            */
            for (int sample = firstRangeSample; sample <= lastRangeSample; sample++) {
                //System.out.println("**** sample = " + sample);
                if (sample > noiseRangeVector.pixels[sampleIdx + 1]
                        && sampleIdx < noiseRangeVector.pixels.length - 2) {
                    sampleIdx++;
                }

                result[i++] = interpol(noiseRangeVector.pixels[sampleIdx],
                        noiseRangeVector.pixels[sampleIdx + 1],
                        noiseRangeVector.noiseLUT[sampleIdx],
                        noiseRangeVector.noiseLUT[sampleIdx + 1], sample);
            }
        }
    }

    private double[] interpolNoiseAzimuthVector(final Sentinel1Utils.NoiseAzimuthVector noiseAzimuthVector) {
        final int numberOfLines = noiseAzimuthVector.lastAzimuthLine - noiseAzimuthVector.firstAzimuthLine + 1;
        if (numberOfLines < 0) {
            SystemUtils.LOG.warning("######### noise vector has no lines");
            return null;
        }
        final double[] interpNoiseAzimVec = new double[numberOfLines];

        int i = 0;
        if (noiseAzimuthVector.lines.length < 2) { // This is possible
            //SystemUtils.LOG.warning("######### noise azimuth vector has length 1");
            for (int line = noiseAzimuthVector.firstAzimuthLine;
                 line <= noiseAzimuthVector.lastAzimuthLine;
                 line++)  {
                interpNoiseAzimVec[i++] = noiseAzimuthVector.noiseAzimuthLUT[0];
            }
        }  else {
            int lineIdx = getLineIndex(noiseAzimuthVector.firstAzimuthLine, noiseAzimuthVector.lines);
            for (int line = noiseAzimuthVector.firstAzimuthLine;
                 line <= noiseAzimuthVector.lastAzimuthLine;
                 line++) {

                if (line > noiseAzimuthVector.lines[lineIdx + 1]
                        && lineIdx < noiseAzimuthVector.lines.length - 2) {
                    lineIdx++;
                }

                interpNoiseAzimVec[i++] = interpol(noiseAzimuthVector.lines[lineIdx],
                        noiseAzimuthVector.lines[lineIdx + 1],
                        noiseAzimuthVector.noiseAzimuthLUT[lineIdx],
                        noiseAzimuthVector.noiseAzimuthLUT[lineIdx + 1],
                        line);
            }
        }

        if (i != numberOfLines) {
            System.out.println("RemoveGRDBorderNoiseOp: DEBUG ERROR i = " + i + " numberOfLines = " + numberOfLines + " ");
        }
        /*
        System.out.println("i = " + i + "; firstAzimuthLine = " + noiseAzimuthVector.firstAzimuthLine);
        if (i == 51) {
            for (int j = 0; j < interpNoiseAzimVec.length; j++) {
                System.out.println("interpNoiseAzimVec[" + j + "] = " + interpNoiseAzimVec[j]);
            }
        }
        */

        return interpNoiseAzimVec;
    }

    private void computeNoiseRangeMatrix(final int firstAzimuthLine, // input
                                         final int lastAzimuthLine, // input
                                         final int noiseRangeVectorLine[], // input
                                         final double interpolatedRangeVectors[][], // input
                                         final double noiseRangeMatrix[][] // output
                                    ) {
        /*
        System.out.println("computeNoiseRangeMatrix: firstAzimuthLine = " + firstAzimuthLine
            + " lastAzimuthLine = " + lastAzimuthLine);
        for (int i = 0; i < noiseRangeVectorLine.length; i++) {
            System.out.println("computeNoiseRangeMatrix: noiseRangeVectorLine[" + i + "] = " + noiseRangeVectorLine[i]);
        }
        */

        final int numSamples = noiseRangeMatrix[0].length;

        if (noiseRangeVectorLine.length == 1) {
            for (int sample = 0; sample < numSamples; sample++) {
                for (int line = 0; line < (lastAzimuthLine - firstAzimuthLine + 1); line++) {
                    noiseRangeMatrix[line][sample] = interpolatedRangeVectors[0][sample];
                }
            }
        } else {
            final int line0Idx = getLineIndex(firstAzimuthLine, noiseRangeVectorLine);

            for (int sample = 0; sample < numSamples; sample++) {
                int i = 0;
                int lineIdx = line0Idx;
                for (int line = firstAzimuthLine; line <= lastAzimuthLine; line++) {

                    if (line > noiseRangeVectorLine[lineIdx + 1]
                            && lineIdx < noiseRangeVectorLine.length - 2) {
                        lineIdx++;
                    }
                    //System.out.println("computeNoiseRangeMatrix: i = " + i + " sample = " + sample);
                    noiseRangeMatrix[i++][sample] = interpol(noiseRangeVectorLine[lineIdx],
                            noiseRangeVectorLine[lineIdx + 1], interpolatedRangeVectors[lineIdx][sample],
                            interpolatedRangeVectors[lineIdx + 1][sample], line);
                }
            }
        }
    }

    private static double interpol(final int x1, final int x2, final double y1, final double y2, final int x) {

        if (x1 == x2) { // should never happen
            SystemUtils.LOG.warning("######### noise vector duplicate indices: x1 == x2  = " + x1);
            return 0;
        }

        return y1 + ((double)(x - x1)/(double)(x2 - x1))*(y2 - y1);
    }

    int[] getNoiseRangeVectorIndices(final String pol, final String swath,
                                     final double startAzimTime, final double endAzimTime,
                                     final Sentinel1Utils.NoiseVector[] noiseRangeVectors,
                                     // for debugging...
                                     final int startAzimLine, final int endAzimLine) {

        // Each noise range vector has an azimuth time (and corresponding azimuth line) associated with it.
        // We want to find the noise range vectors in "noiseRangeVectors" whose azimuth time lies with
        // the interval defined by [startAzimTime, endAzimTime].
        // If no such range vector exists, then find the one that lies within the swath (of the azimuth block)
        // start and end times and is closest to the centre of the azimuth block.
        // Noise range vector is not associated with a swath.

        //System.out.println("getNoiseRangeVectorIndices: called");
        List<Integer> list = new ArrayList<>();

        for (int i = 0; i < noiseRangeVectors.length; i++) {
            final double azimTime = noiseRangeVectors[i].timeMJD;
            if (azimTime >= startAzimTime && azimTime <= endAzimTime) {
                list.add(i);
            }
        }
        //System.out.println("getNoiseRangeVectorIndices: list.size() = " + list.size());

        if (list.size() == 0) {
            int idx = -1;
            final double[] startEndTimes = new double[2];
            getSwathStartEndTimes(pol, swath, startEndTimes);
            /*
            System.out.println("getNoiseRangeVectorIndices: " + pol + " " + swath
                    + " startAzimLine = " + startAzimLine + " endAzimLine = " + endAzimLine
                    + " startAximTime = " + startAzimTime + " endAzimTime = " + endAzimTime
                    + " startSwathTime = " + startEndTimes[0] + " endSwathTime = " + startEndTimes[1]);
            */
            final double blockCentreTime = (startAzimTime + endAzimTime) / 2.0;
            for (int i = 0; i < noiseRangeVectors.length; i++) {
                final double azimTime = noiseRangeVectors[i].timeMJD;
                if (azimTime >= startEndTimes[0] && azimTime <= startEndTimes[1]) {
                    if (idx < 0) {
                        idx = i;
                    } else if (Math.abs(blockCentreTime - noiseRangeVectors[i].timeMJD) <
                            Math.abs(blockCentreTime - noiseRangeVectors[idx].timeMJD)) {
                        idx = i;
                    }
                }
            }
            if (idx < 0) {
                SystemUtils.LOG.warning("######### No valid range vector found for startAzimTime = " + startAzimTime + " endAzimTime = " + endAzimTime + " swath = " + swath);
                return null;
            } else {
                list.add(idx);
            }
        }

        int[] indices = new int[list.size()];
        for (int i = 0; i < indices.length; i++) {
            indices[i] = list.get(i);
        }

        return indices;
    }

    void getSwathStartEndTimes(final String pol, final String swath, final double[] startEndtimes) {

        final String key = pol + "+" + swath;

        startEndtimes[0] = 0; // start time
        startEndtimes[1] = 0; // end time

        if (swathStartEndTimesMap.containsKey(key)) {
            double[] times = swathStartEndTimesMap.get(key);
            startEndtimes[0] = times[0];
            startEndtimes[1] = times[1];
            return;
        }

        final MetadataElement annotationElem = origMetadataRoot.getElement("annotation");
        final MetadataElement[] annotationDataSetListElem = annotationElem.getElements();

        for (MetadataElement elem : annotationDataSetListElem)  {
            final String imageName = elem.getName();
            if (imageName.toLowerCase().contains(pol.toLowerCase())) {
                //System.out.println("getSwathStartEndTimes: found " + pol);
                final MetadataElement productElem = elem.getElement("product");
                final MetadataElement swathMergingElem = productElem.getElement("swathMerging");
                final MetadataElement swathMergeListElem = swathMergingElem.getElement("swathMergeList");
                final MetadataElement[] swathMergeArray = swathMergeListElem.getElements();
                for (int i = 0; i < swathMergeArray.length; i++) {
                    final String curSwath = swathMergeArray[i].getAttributeString("swath");
                    if (curSwath.equals(swath)) {
                        //System.out.println("getSwathStartEndTimes: found " + key);
                        MetadataElement swathBoundsListElem = swathMergeArray[i].getElement("swathBoundsList");
                        MetadataElement[] swathBoundList = swathBoundsListElem.getElements();
                        final int startLine = swathBoundList[0].getAttributeInt("firstAzimuthLine");
                        final int lastIdx = swathBoundList.length - 1;
                        final int endLine = swathBoundList[lastIdx].getAttributeInt("lastAzimuthLine");
                        if (t0Map.containsKey(imageName) && deltaTsMap.containsKey(imageName)) {
                            final double t0 = t0Map.get(imageName);
                            final double deltaTs = deltaTsMap.get(imageName);
                            startEndtimes[0] = t0 + (startLine * deltaTs);
                            startEndtimes[1] = t0 + (endLine * deltaTs);
                            swathStartEndTimesMap.put(key, startEndtimes);
                            /*
                            System.out.println("getSwathStartEndTimes: " + key + " -> [" + startEndtimes[0] + ", " + startEndtimes[1] + "]"
                                + " [" + startLine + ", " + endLine + "]");
                            */
                        } else {
                            SystemUtils.LOG.warning("######### fail to find swath start and end times for "
                                    + pol + " " + swath);
                        }
                        return;
                    }
                }
            }
        }
    }


    /**
     * Compute noise LUTs for pixels of a whole range line for given noise vector.
     */
    private void computeNoiseLUT() {

        try {
            noiseLUT = new double[sourceImageWidth];

            if (!thermalNoiseCorrectionPerformed) {
                int pixelIdx = getPixelIndex(0, noiseVector);
                final int maxLength = noiseVector.pixels.length - 2;
                for (int x = 0; x < sourceImageWidth; x++) {

                    if (x > noiseVector.pixels[pixelIdx + 1] && pixelIdx < maxLength) {
                        pixelIdx++;
                    }

                    final int xx0 = noiseVector.pixels[pixelIdx];
                    final int xx1 = noiseVector.pixels[pixelIdx + 1];
                    final double muX = (double) (x - xx0) / (double) (xx1 - xx0);

                    noiseLUT[x] = Maths.interpolationLinear(
                            noiseVector.noiseLUT[pixelIdx], noiseVector.noiseLUT[pixelIdx + 1], muX) * scalingFactor;
                }
            } else {
                for (int x = 0; x < sourceImageWidth; x++) {
                    noiseLUT[x] = 0.0;
                }
            }
        } catch (Throwable e) {
            OperatorUtils.catchOperatorException("computeNoiseLUT", e);
        }
    }

    /**
     * Get pixel index in a given noise vector for a given pixel.
     *
     * @param x           Pixel coordinate.
     * @param noiseVector Noise vector.
     * @return The pixel index.
     */
    private static int getPixelIndex(final int x, final Sentinel1Utils.NoiseVector noiseVector) {

        for (int i = 0; i < noiseVector.pixels.length; i++) {
            if (x < noiseVector.pixels[i]) {
                return i - 1;
            }
        }
        return noiseVector.pixels.length - 2;
    }

    private static int getLineIndex(final int line, final int lines[]) {

        //  lines.length is assumed to be >= 2

        for (int i = 0; i < lines.length; i++) {
            if (line < lines[i]) {
                return (i > 0) ? i - 1 : 0;
            }
        }

        //System.out.println("getLineIndex: reach the end for line = " + line);
        return lines.length - 2;
    }

    private static int getSampleIndex(final int sample, final Sentinel1Utils.NoiseVector noiseRangeVector) {

        for (int i = 0; i < noiseRangeVector.pixels.length; i++) {
            if (sample < noiseRangeVector.pixels[i]) {
                return (i > 0) ? i - 1 : 0;
            }
        }

        return noiseRangeVector.pixels.length - 2;
    }

    /**
     * Compute noise scaling factor.
     */
    private void computeNoiseScalingFactor() throws IOException {

        if (version < 2.50) {
            final String acquisitionMode = absRoot.getAttributeString(AbstractMetadata.ACQUISITION_MODE);
            double knoise;
            if (acquisitionMode.contains("IW")) {
                knoise = 75088.7;
            } else if (acquisitionMode.contains("EW")) {
                knoise = 56065.87;
            } else {
                throw new OperatorException("Cannot apply the operator to the input GRD product.");
            }

            final double dn0 = getDN0();

            if (version < 2.34) {
                scalingFactor = knoise * dn0;
            } else {
                scalingFactor = knoise * dn0 * dn0;
            }

        } else {
            scalingFactor = 1.0;
        }
    }

    /**
     * Get the first element in DN vector from the original product metadata.
     */
    private double getDN0() throws IOException {

        String[] selectedPols = {coPolarization};
        Sentinel1Calibrator.CalibrationInfo[] calibration = Sentinel1Calibrator.getCalibrationVectors(
                sourceProduct, Arrays.asList(selectedPols), false, false, false, true);

        for (Sentinel1Calibrator.CalibrationInfo cal : calibration) {
            if (cal.polarization.contains(coPolarization)) {

                final float[] dnLUT = Sentinel1Calibrator.getVector(
                        Sentinel1Calibrator.CALTYPE.DN, cal.getCalibrationVector(0));

                return dnLUT[0];
            }
        }

        return 0.0;
    }

    /**
     * Create a target product for output.
     */
    private void createTargetProduct() {

        targetProduct = new Product(sourceProduct.getName(),
                sourceProduct.getProductType(),
                sourceImageWidth,
                sourceImageHeight);

        addSelectedBands();

        ProductUtils.copyProductNodes(sourceProduct, targetProduct);
    }

    /**
     * Add user selected bands to target product.
     */
    private void addSelectedBands() {

        final Band[] sourceBands = sourceProduct.getBands();
        for (Band srcBand : sourceBands) {

            final String unit = srcBand.getUnit();
            if (unit == null) {
                throw new OperatorException("band " + srcBand.getName() + " requires a unit");
            }

            if (!unit.contains(Unit.AMPLITUDE) && !unit.contains(Unit.INTENSITY)) {
                continue;
            }

            final String srcBandName = srcBand.getName();
            if (selectedPolarisations != null && selectedPolarisations.length != 0 &&
                    !containSelectedPolarisations(srcBandName)) {
                continue;
            }

            if (srcBand instanceof VirtualBand) {

                ProductUtils.copyVirtualBand(targetProduct, (VirtualBand) srcBand, srcBand.getName());
            } else {

                final Band targetBand = new Band(
                        srcBandName,
                        srcBand.getDataType(),
                        srcBand.getRasterWidth(),
                        srcBand.getRasterHeight());

                targetBand.setUnit(srcBand.getUnit());
                targetBand.setNoDataValue(srcBand.getNoDataValue());
                targetBand.setNoDataValueUsed(srcBand.isNoDataValueUsed());
                targetBand.setDescription(srcBand.getDescription());
                targetProduct.addBand(targetBand);
            }
        }
    }

    private boolean containSelectedPolarisations(final String bandName) {
        for (String pol : selectedPolarisations) {
            if (bandName.contains(pol)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Called by the framework in order to compute a tile for the given target band.
     * <p>The default implementation throws a runtime exception with the message "not implemented".</p>
     *
     * @param targetTileMap   The target tiles associated with all target bands to be computed.
     * @param targetRectangle The rectangle of target tile.
     * @param pm              A progress monitor which should be used to determine computation cancelation requests.
     * @throws OperatorException If an error occurs during computation of the target raster.
     */
    @Override
    public void computeTileStack(Map<Band, Tile> targetTileMap, Rectangle targetRectangle, ProgressMonitor pm)
            throws OperatorException {

        try {
            if (version < 2.9 && useBorderDetection && !borderDetected) {
                detectBorders();
            }

            final int x0 = targetRectangle.x;
            final int y0 = targetRectangle.y;
            final int w = targetRectangle.width;
            final int h = targetRectangle.height;
            final int yMax = y0 + h;
            final int xMax = x0 + w;
            //System.out.println("x0 = " + x0 + ", y0 = " + y0 + ", w = " + w + ", h = " + h);

            final Set<Band> keySet = targetTileMap.keySet();
            final int numBands = keySet.size();
            final ProductData[] targetData = new ProductData[numBands];
            final ProductData[] sourceData = new ProductData[numBands];
            final Tile[] sourceTile = new Tile[numBands];
            final Tile[] targetTile = new Tile[numBands];
            final double[] bandNoDataValues = new double[numBands];

            int k = 0;
            for (Band targetBand : keySet) {
                targetTile[k] = targetTileMap.get(targetBand);
                targetData[k] = targetTile[k].getDataBuffer();

                final Band srcBand = sourceProduct.getBand(targetBand.getName());
                sourceTile[k] = getSourceTile(srcBand, targetRectangle);
                sourceData[k] = sourceTile[k].getDataBuffer();
                bandNoDataValues[k] = srcBand.getNoDataValue();
                k++;
            }

            final TileIndex srcIndex = new TileIndex(sourceTile[0]);
            final TileIndex tgtIndex = new TileIndex(targetTile[0]);

            if (version < 2.9) {
                final Tile coPolTile = getSourceTile(coPolBand, targetRectangle);
                final ProductData coPolData = coPolTile.getDataBuffer();

                double coPolDataValue, deNoisedDataValue;
                for (int y = y0; y < yMax; y++) {
                    srcIndex.calculateStride(y);
                    tgtIndex.calculateStride(y);

                    for (int x = x0; x < xMax; x++) {
                        final int srcIdx = srcIndex.getIndex(x);

                        boolean testPixel = x < leftBorder || x > rightBorder || y < topBorder || y > bottomBorder;

                        if (testPixel) {
                            coPolDataValue = coPolData.getElemDoubleAt(srcIdx);
                            if (noDataValue.equals(coPolDataValue)) {
                                continue;
                            }

                            deNoisedDataValue =
                                    Math.sqrt(Math.max(coPolDataValue * coPolDataValue - noiseLUT[x], 0.0));

                            if (deNoisedDataValue < trimThreshold || coPolDataValue < 30) {
                                final int tgtIdx = tgtIndex.getIndex(x);
                                for (int i = 0; i < numBands; i++) {
                                    targetData[i].setElemDoubleAt(tgtIdx, bandNoDataValues[i]);
                                }
                            } else {
                                testPixel = false;
                            }
                        }

                        if (!testPixel) {
                            final int tgtIdx = tgtIndex.getIndex(x);
                            for (int i = 0; i < numBands; i++) {
                                targetData[i].setElemDoubleAt(tgtIdx, sourceData[i].getElemDoubleAt(srcIdx));
                            }
                        }
                    }
                }
            } else {
                // TODO subrtact the noise
                for (int y = y0; y < yMax; y++) {
                    srcIndex.calculateStride(y);
                    tgtIndex.calculateStride(y);

                    for (int x = x0; x < xMax; x++) {
                        final int srcIdx = srcIndex.getIndex(x);

                        final int tgtIdx = tgtIndex.getIndex(x);
                        for (int i = 0; i < numBands; i++) {
                            targetData[i].setElemDoubleAt(tgtIdx, sourceData[i].getElemDoubleAt(srcIdx));
                        }

                    }
                }
            }

        } catch (Throwable e) {
            throw new OperatorException(e.getMessage());
        }
    }

    private synchronized void detectBorders() throws OperatorException {

        if (borderDetected) return;

        detectBorder();

        SystemUtils.LOG.fine("topBorder = " + topBorder);
        SystemUtils.LOG.fine("bottomBorder = " + bottomBorder);
        SystemUtils.LOG.fine("leftBorder = " + leftBorder);
        SystemUtils.LOG.fine("rightBorder = " + rightBorder);

        borderDetected = true;
    }

    private enum SIDE {TOP, BOTTOM, LEFT, RIGHT}

    private void detectBorder() throws OperatorException {

        final Dimension tileSize = new Dimension(borderLimit, borderLimit);
        final Rectangle[] topRectangles = getAllTileRectangles(0, 0, sourceImageWidth, borderLimit, tileSize);
        final Rectangle[] bottomRectangles = getAllTileRectangles(
                0, sourceImageHeight - borderLimit, sourceImageWidth, borderLimit, tileSize);
        final Rectangle[] leftRectangles = getAllTileRectangles(0, 0, borderLimit, sourceImageHeight, tileSize);
        final Rectangle[] rightRectangles = getAllTileRectangles(
                sourceImageWidth - borderLimit, 0, borderLimit, sourceImageHeight, tileSize);

        final List<Border> borderList = new ArrayList<>(4);
        borderList.add(new Border(SIDE.TOP, borderLimit, topRectangles));
        borderList.add(new Border(SIDE.BOTTOM, borderLimit, bottomRectangles));
        borderList.add(new Border(SIDE.LEFT, borderLimit, leftRectangles));
        borderList.add(new Border(SIDE.RIGHT, borderLimit, rightRectangles));

        final int totalRects = topRectangles.length + bottomRectangles.length + leftRectangles.length + rightRectangles.length;
        final ThreadManager threadManager = new ThreadManager();
        final StatusProgressMonitor status = new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
        status.beginTask("Detecting border... ", totalRects);

        try {
            for (Border border : borderList) {

                for (final Rectangle rectangle : border.tileRectangles) {

                    final Thread worker = new Thread() {

                        final int xMax = rectangle.x + rectangle.width;
                        final int yMax = rectangle.y + rectangle.height;

                        @Override
                        public void run() {
                            final Tile coPolTile = getSourceTile(coPolBand, rectangle);
                            final ProductData coPolData = coPolTile.getDataBuffer();
                            final TileIndex srcIndex = new TileIndex(coPolTile);

                            if (border.side.equals(SIDE.TOP) || border.side.equals(SIDE.BOTTOM)) {
                                final double[] colSum = new double[borderLimit];
                                for (int y = rectangle.y; y < yMax; ++y) {
                                    srcIndex.calculateStride(y);
                                    final int yy = y - rectangle.y;
                                    double sum = 0.0;
                                    for (int x = rectangle.x; x < xMax; ++x) {
                                        final double v = coPolData.getElemDoubleAt(srcIndex.getIndex(x));
                                        if (v != noDataValue) {
                                            sum += v;
                                        }
                                    }
                                    colSum[yy] += sum;
                                }

                                synchronized (border.avg) {
                                    for (int r = 0; r < borderLimit; r++) {
                                        border.avg[r] += (colSum[r] / rectangle.width);
                                    }
                                }
                            } else {
                                final double[] rowSum = new double[borderLimit];
                                for (int x = rectangle.x; x < xMax; ++x) {
                                    final int xx = x - rectangle.x;
                                    double sum = 0.0;
                                    for (int y = rectangle.y; y < yMax; ++y) {
                                        final double v = coPolData.getElemDoubleAt(coPolTile.getDataBufferIndex(x, y));
                                        if (v != noDataValue) {
                                            sum += v;
                                        }
                                    }
                                    rowSum[xx] += sum;
                                }

                                synchronized (border.avg) {
                                    for (int c = 0; c < borderLimit; c++) {
                                        border.avg[c] += (rowSum[c] / rectangle.height);
                                    }
                                }
                            }
                        }
                    };

                    threadManager.add(worker);
                    status.worked(1);
                }
            }
            threadManager.finish();

        } catch (Exception e) {
            OperatorUtils.catchOperatorException(getId() + " detectBorder ", e);
        } finally {
            status.done();
        }

        for (Border border : borderList) {
            for (int r = 0; r < borderLimit; r++) {
                border.avg[r] /= border.tileRectangles.length;
            }

            final int peakPos = getPeakPosition(border.avg);
            switch (border.side) {
                case TOP: {
                    if (peakPos == -1) {
                        topBorder = 0;
                    } else {
                        topBorder = peakPos;
                    }
                    break;
                }
                case BOTTOM: {
                    if (peakPos == -1) {
                        bottomBorder = sourceImageHeight - 1;
                    } else {
                        bottomBorder = sourceImageHeight - borderLimit + peakPos;
                    }
                    break;
                }
                case LEFT: {
                    if (peakPos == -1) {
                        leftBorder = 0;
                    } else {
                        leftBorder = peakPos;
                    }
                    break;
                }
                case RIGHT: {
                    if (peakPos == -1) {
                        rightBorder = sourceImageWidth - 1;
                    } else {
                        rightBorder = sourceImageWidth - borderLimit + (int) (peakPos * 0.8);
                    }
                    break;
                }
            }
        }
    }

    private static class Border {
        public final SIDE side;
        public final double[] avg;
        public final Rectangle[] tileRectangles;

        public Border(final SIDE side, final int borderLimit, final Rectangle[] rectangles) {
            this.side = side;
            this.avg = new double[borderLimit];
            this.tileRectangles = rectangles;
        }
    }

    public static Rectangle[] getAllTileRectangles(
            final int x0, final int y0, final int width, final int height, final Dimension tileSize) {

        final Rectangle boundary = new Rectangle(x0, y0, width, height);
        final int tileCountX = MathUtils.ceilInt(boundary.width / (double) tileSize.width);
        final int tileCountY = MathUtils.ceilInt(boundary.height / (double) tileSize.height);
        final Rectangle[] rectangles = new Rectangle[tileCountX * tileCountY];

        int index = 0;
        for (int y = y0; y < y0 + height; y += tileSize.height) {
            for (int x = x0; x < x0 + width; x += tileSize.width) {
                final Rectangle tileRectangle = new Rectangle(x, y, tileSize.width, tileSize.height);
                final Rectangle intersection = boundary.intersection(tileRectangle);
                rectangles[index] = intersection;
                index++;
            }
        }
        return rectangles;
    }

    private static int getPeakPosition(final double[] array) {

        final double[] derivative = new double[array.length - 1];
        for (int i = 0; i < derivative.length; i++) {
            derivative[i] = Math.abs(array[i + 1] - array[i]);
        }

        int maxIdx = -1;
        double max = -Double.MAX_VALUE;
        double mean = 0.0;
        for (int i = 0; i < derivative.length; i++) {
            mean += derivative[i];
            if (max < derivative[i]) {
                max = derivative[i];
                maxIdx = i;
            }
        }

        mean /= derivative.length;
        if (mean > 0.0 && max / mean > 10.0) {
            return maxIdx;
        } else {
            return -1;
        }
    }

    private final static class NoiseAzimuthBlock {
        final String swath;
        final int firstAzimuthLine;
        final int firstRangeSample;
        final int lastAzimuthLine;
        final int lastRangeSample;

        final int numSamples;
        final int numLines;

        final double[][] noiseMatrix;

        //final double[] interpNoiseAzimVec; // length = lastAzimuthLine - firstAzimuthLine + 1
        //double[][] interpNoiseRangeMatrix;

        NoiseAzimuthBlock(final String swath,
                          final int firstAzimuthLine, final int firstRangeSample,
                          final int lastAzimuthLine, final int lastRangeSample,
                          final double[][] noiseMatrix)
                          //final double[] interpNoiseAzimVec)
        {
            this.swath = swath;
            this.firstAzimuthLine = firstAzimuthLine;
            this.firstRangeSample = firstRangeSample;
            this.lastAzimuthLine = lastAzimuthLine;
            this.lastRangeSample = lastRangeSample;
            this.noiseMatrix = noiseMatrix;

            numSamples = lastRangeSample - firstRangeSample + 1;
            numLines = lastAzimuthLine - firstAzimuthLine + 1;

            //this.interpNoiseAzimVec = interpNoiseAzimVec;
            //interpNoiseRangeMatrix = new double[numLines][numSamples];
        }
    }

    /**
     * The SPI is used to register this operator in the graph processing framework
     * via the SPI configuration file
     * {@code META-INF/services/org.esa.snap.core.gpf.OperatorSpi}.
     * This class may also serve as a factory for new operator instances.
     *
     * @see OperatorSpi#createOperator()
     * @see OperatorSpi#createOperator(java.util.Map, java.util.Map)
     */
    public static class Spi extends OperatorSpi {
        public Spi() {
            super(RemoveGRDBorderNoiseOp.class);
        }
    }
}
